#!/usr/bin/env php
<?php

declare(strict_types=1);

use Filacheck\Fixer\CodeFixer;
use Filacheck\Reporting\StandaloneReporter;
use Filacheck\FilacheckServiceProvider;
use Filacheck\Rules\BladeRule;
use Filacheck\Scanner\ResourceScanner;
use Filacheck\Support\RuleRegistry;
use Symfony\Component\Console\Output\ConsoleOutput;

// Autoload handling for different installation contexts
$autoloadPaths = array_filter([
    $GLOBALS['_composer_autoload_path'] ?? null, // Composer bin proxy (most reliable)
    __DIR__.'/../../../autoload.php',            // Installed as dependency
    __DIR__.'/../../../../vendor/autoload.php',  // Laravel project context
    __DIR__.'/../vendor/autoload.php',           // Package development
]);

$autoloaded = false;
foreach ($autoloadPaths as $autoloadPath) {
    if (file_exists($autoloadPath)) {
        require $autoloadPath;
        $autoloaded = true;
        break;
    }
}

if (! $autoloaded) {
    fwrite(STDERR, "Error: Could not find autoloader. Run 'composer install' first.\n");
    exit(1);
}

function isAbsolutePath(string $path): bool
{
    return str_starts_with($path, '/') || preg_match('/^[A-Za-z]:[\\\\\/]/', $path) === 1;
}

$output = new ConsoleOutput();

// Parse arguments
$args = array_slice($argv, 1);
$path = null;
$verbose = false;
$fix = false;
$dryRun = false;
$backup = false;
$showHelp = false;
$showVersion = false;

foreach ($args as $arg) {
    if ($arg === '--help' || $arg === '-h') {
        $showHelp = true;
    } elseif ($arg === '--version' || $arg === '-V') {
        $showVersion = true;
    } elseif ($arg === '--detailed' || $arg === '-d') {
        $verbose = true;
    } elseif ($arg === '--fix') {
        $fix = true;
    } elseif ($arg === '--dry-run') {
        $dryRun = true;
    } elseif ($arg === '--backup') {
        $backup = true;
    } elseif (! str_starts_with($arg, '-')) {
        $path = $arg;
    }
}

$version = fn () => trim(shell_exec('git describe --tags --abbrev=0 2>/dev/null') ?? '') ?: 'dev';

if ($showVersion) {
    $output->writeln('FilaCheck <info>'.$version().'</info>');
    exit(0);
}

if ($showHelp) {
    $output->writeln('FilaCheck <info>'.$version().'</info>');
    $output->writeln('');
    $output->writeln('<fg=yellow>Usage:</>');
    $output->writeln('  filacheck [path] [options]');
    $output->writeln('');
    $output->writeln('<fg=yellow>Arguments:</>');
    $output->writeln('  path                  Directory or file to scan (default: app/Filament)');
    $output->writeln('');
    $output->writeln('<fg=yellow>Options:</>');
    $output->writeln('  -d, --detailed        Show detailed output with rule categories');
    $output->writeln('  --fix                 Automatically fix issues where possible');
    $output->writeln('  --dry-run             Preview fix changes without modifying files (requires --fix)');
    $output->writeln('  --backup              Create backup files when fixing (requires --fix)');
    $output->writeln('  -h, --help            Display this help message');
    $output->writeln('  -V, --version         Display version');
    $output->writeln('');
    $output->writeln('<fg=yellow>Examples:</>');
    $output->writeln('  filacheck                           Scan app/Filament directory');
    $output->writeln('  filacheck app/Filament/Resources    Scan specific directory');
    $output->writeln('  filacheck app/Filament/Resources/UserResource.php    Scan specific file');
    $output->writeln('  filacheck --detailed                Show detailed report');
    $output->writeln('  filacheck --fix                     Auto-fix issues');
    $output->writeln('  filacheck --fix --dry-run           Preview fixes without writing files');
    $output->writeln('  filacheck --fix --backup            Auto-fix with backups');
    exit(0);
}

if ($dryRun && ! $fix) {
    $output->writeln('<fg=red>Error:</> The --dry-run option requires --fix.');
    exit(1);
}

// Default path
if ($path === null) {
    $path = getcwd().DIRECTORY_SEPARATOR.'app'.DIRECTORY_SEPARATOR.'Filament';
}

// Make relative paths absolute
if (! isAbsolutePath($path)) {
    $path = getcwd().DIRECTORY_SEPARATOR.$path;
}

if (! is_dir($path) && ! is_file($path)) {
    $output->writeln("<fg=red>Error:</> Path not found: {$path}");
    exit(1);
}

$output->writeln("Scanning: <fg=gray>{$path}</>");
$output->writeln('');

$scanner = new ResourceScanner();

$registry = new RuleRegistry();

$registry->register(FilacheckServiceProvider::rules());

// Pro rules (auto-detected if installed)
$proProvider = 'FilacheckPro\\FilacheckProServiceProvider';
if (class_exists($proProvider)) {
    $registry->register($proProvider::rules());
}

foreach ($registry->all() as $rule) {
    $scanner->addRule($rule);
}

$violations = $scanner->scan($path, getcwd());

$hasBladeRules = array_filter($scanner->getRules(), fn ($rule) => $rule instanceof BladeRule);

if (! empty($hasBladeRules)) {
    $bladeDir = getcwd().DIRECTORY_SEPARATOR.'resources'.DIRECTORY_SEPARATOR.'views'.DIRECTORY_SEPARATOR.'filament';
    $bladeViolations = $scanner->scanBladeFiles($bladeDir, getcwd());
    $violations = array_merge($violations, $bladeViolations);
}

$reporter = new StandaloneReporter($output, $verbose);

if ($fix && count($violations) > 0) {
    $fixer = new CodeFixer();
    $fixResults = $fixer->fix($violations, $backup, $dryRun);

    $reporter->reportWithFixes($scanner->getRules(), $violations, $fixResults);

    exit($fixResults['skipped'] > 0 ? 1 : 0);
}

$reporter->report($scanner->getRules(), $violations);

exit(count($violations) > 0 ? 1 : 0);
